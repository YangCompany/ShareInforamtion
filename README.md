# ShareInforamtion
지식 공유

1. OSI 계층 설명 / 대표장비 / 데이터 단위

Physical(관련 장비 : 허브)
Data Link(관련 장비 : 스위치)
Network(관련 장비 : 라우터)
Transport(관련 장비 : 게이트 웨이)
Session
Presentation
Application
위와 같은 7계층으로 나누어 집니다.
데이터를 전송할 때 각각의 층마다 인식하는 헤더를 붙이게 되는데
이러한 과정을 일종의 캡슐화라고 합니다.
즉, 캡슐화와 디캡슐레이션을 통해 층별 통신을 하는 7단계로 구성된
프로토콜 표준 모델입니다.

2. TCP, UDP 차이

TCP
연결형 서비스 프로토콜 입니다.
인터넷 환경에서 기본으로 사용되며
3-way-handshaking 을 통해 높은 신뢰성을 보장합니다.

UDP
비연결형 서비스 프로토콜 입니다.
TCP의 3-way-hanshaking과는 달리 정보를 보낸다는 신호나,
받는다는 신호 절차 없이 일방적으로 데이터를 전달하기때문에
신뢰성이 낮습니다.

3. Thread, Process 차이

이론적인 개념과 경험을 통해 알게 된 느낌 두가지 버전이 있습니다만
이론적인 개념으로 설명하겠습니다.
설명하기에 앞서 program이라는 개념도 설명하겠습니다.

프로그램은 메모장과 같이 하나의 실행 가능한 단위입니다.
소스코드들로 이루어져 실행을 기다리는 것입니다.

이 것이 메모리에 마운트 되어 실행되면 이것을 프로세스라고 칭합니다.
즉, 프로그램이 실행되면 프로세스가 되는 것 입니다.

그 프로세스 안에 Thread의 개념이 들어갑니다. 실행되고 있는 프로그램 즉 프로세스의
동작 즉 명령을 수행하는 것이 스레드이며 여러 개의 스레드를 활용하는 멀티 스레드를 통해
분산 작업이 가능합니다.

이론상으로는 이렇게 설명할 수 있지만 제가 직접 안드로이드 개발을 하며
느낀 바로 설명을 하자면

제가 직접 작성한 안드로이드 어플리케이션은 프로그램이 됩니다.
어플리케이션을 작동시키면 실행이되고 그때부터 프로세스가 되며
프로세스 내에서 제가 프로그램 흐름을 제어하기 위해 Main thread와 통신을 담당하는
비동기 Thread를 사용했고 그에 따라 흘러가는 실행의 흐름 자체가 thread라고 생각합니다.


4. Linux / Unix / Window특징

Unix가 먼저 세상에 태어나고 그다음 Unix의 장점을 포함하며
여러 기능을 적용한 Linux가 탄생하게 되었습니다.

Unix의 관리는 IBM에서 일괄 관리를 하지만 Linux는 개방형이기 때문에
사용자들에 의해 지속적인 성장이 가능합니다.

둘다 서버 운영체제로 적합하며 암호화 능력 과 메모리 관리 능력 등의 안전성을 고려한다면
Unix가 좋습니다.

Linux같은 경우엔 과중한 네트워크 부하를 처리 할 때 최적화 된 성능을 발휘하지는 못합니다.

Window는 코드 비공개 방침으로 인해, 비공식적 무상지원이 없으며, 버그 수정도 MS 스케쥴에 따라 해결 됩니다.
또한 대량의 네트워크 부하를 감당해내지 못합니다.


5. DataBase 정규화 설명

설계단계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 DataBase 정규화라고 합니다.
총 7단계가 있으며 평균적으로 3단계까지 완료 되었으면 정규화 되었다고 합니다.
3단계의 이름은 Third Normal Form 줄여서 3NF로 칭하며 
1단계를 포함한 2단계의 테이플에 존재하는 함수 종속 관계가 완전 함수 종속이며
어떠한 테이블에 존재하는 key가 아닌 필드들이 서로 독립적인 경우를 말합니다.


6. VPN / NAT 설명

NAT은 Local IP Address를 가진 host가 마치 global IP Address를 가진 것처럼 행동 하기 위한 라우터의 기능
VPN은 가상 사설망으로써 공중망을 통한 연결을 전용선처럼 사용하는 효과를 누리도록 하는 것
즉 VPN은 인트라넷 등에 이용하며 데이터를 암호화하고 수신측에서 복호화하는 방식으로 데이터를 송수신합니다.

7. TCP / IP 설명

인터넷 모델이라고 불리며, Network Interface, Internet, Transport, Application 과 같이 4계층으로 이루어져 있습니다.
Network Interface == OSI 의 1,2 계층에 해당
물리적 주소인 MAC주소를 이용해서 패킷 보낼 곳 판단

Internet == OSI의 3계층에 해당
논리적 주소인 IP를 이용한 전송과 라우팅 기능 처리

Transport == OSI의 3,4, 계층에 해당
자료의 송수신 담당, 데이터에 대한 제어정보 포함

Application == OSI의 5,6,7 계층에 해당
프로그램에서 소켓을 생성하여 원하는 메시지 혹은 데이터를 전송함

8. 스택과 큐의 차이

스택
LIFO 즉, 후입선출의 데이터 구조
자료가 없을 때 pop하면 Stack Underflow가 나고, 자료가 꽉 찼을때 push하면
Stack Overflow가 발생

큐
FIFO 즉, 선입선출의 데이터 구조
데이터를 꺼낼 때 다른 데이터를 차례대로 당겨주어야 해서 많은 데이터의 경우
연산에 많은 시간이 걸리며 이러한 문제점을 해결하기 위해 원형 큐의 방법이 나옴

9. XML이란?
eXtensible Markup Language로 불리며 html과는 달리 사용자가 임의로 만들어 태그를 사용 할 수 있습니다.
태그를 이용해 데이터를 설명 할 수 있습니다.
마크업 언어가 아닌 마크업 언어를 정의하기 위한 언어라고 보면 쉽다.

안드로이드에서 xml을 사용해 메타 데이터를 다뤄본 경험으로 자연스럽게 체득한 개념입니다.

10. RSS란?
Really Simple Syndication, 즉 웹사이트나 블로그에서 제공하는 RSS주소를 리더에 등록해주면
직접 방문하지 않아도 자동으로 자료가 업데이트되어 정보를 확인 할 수 있는 인터넷 기술입니다.

RSS를 제공받기 위해서는 사이트에서 RSS피드를 제공해줘야 합니다.


11. Call by Value 와 Call by Reference 차이

데이터의 값을 중심으로 보는지, 주소를 중심으로 보는지의 차이입니다.
Call by Value를 통해 처리하면 연산 후 기존의 주소에 등록되어있는 값이 변하지 않으며,
Call by Reference를 통해 처리하면 연산 후 기존의 주소에 등록되어있는 값이 변하게 됩니다.

자바의 경우 기본 데이터형에 대해서는 Call by Value로 호출하며, 객체에 대해서는 Call by Reference로 호출합니다.

12. Three Hands Shake 설명

기본적으로 SYN, SYN/ACK, ACK 을 사용하며 TCP통신을 위한 네트워크 통신에 사용된다.
첫번째로 Client로 Server에 연결 요청을 하기 위해 SYN을 보냅니다.
두번째로 Server에서는 SYN데이터를 받고 정상적으로 받았다는 대답인 ACK과 Client포트를 열라는 SYN을 같이 보냅니다.
마지막으로 Client가 SYN / ACK을 받았다면 ESTABLISHED 상태로 변경하고 서버에 요청을 받았다는 ACK을 전송하고 서버는 상태가 Client와 같이 ESTABLISHED로 변경 됩니다.


13. CPU 스케쥴링

여러 개의 프로그램들이 실행된 상태에서 어떤 순서로 각 프로세스를 돌릴지 결정하는 기능이며 즉, 시스템 자원을
언제 배분 할 것인가를 결정하는 것 입니다.

방법으로는 첫번째, 선점 스케줄링이 있으며, 운영체제 프로세서 자원을 선점하고 있다가 각 프로세스의 요청이 있을 때 특정 요건을 기준으로 자원을 배분하는 방식입니다.

- SRT(Shortest Remaining Time) 기법
새로 도착한 프로세스를 비롯하여 대기 큐에 남아 있는 프로세스의 남은 작업 시간이 가장 적은
프로세스에 먼저 CUP를 할당합니다.

- RR(Round Robin)기법
프로세스가 큐에 적재되어 주어진 시간 할당량동안 작업을 할 수 있습니다.
주어진 시간이 지나도 작업이 끝나지 않으면 대기 큐의 맨뒤로 돌아갑니다.

두번째로는 비선점 스케줄링이 있습니다. 어떤 프로세스가 CPU 할당을 받으면 그 프로세스가 종료되거나
입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되는 방법으로 순서대로 처리되는 특징이 있습니다.

- FCFS(First-Come, First-Served) 기법
먼저 대기 큐에 들어온 프로세스에 CPU를 먼저 할당하는 방식입니다.

- SJF(Shortest Job First)
처리 해야 할 작업 시간이 가장 적은 프로세스에 CPU를 할당하는 방식입니다.


14. Pointer 와 배열의 차이

포인터는 고유의 메모리를 차지하고 있고 언제든 다른 대상을 가리킬 수 있는 변수이며,
배열은 오직 맨앞의 번지수를 읽을 수 있을 뿐인 상수입니다.

포인터가 가르키는 배열의 크기는 동적으로 결정이 가능하지만, 배열이 가르키는 배열의 크기는
선언 할 때 정적으로 결정됩니다.

함수로 전달 할 경우에 포인터를 사용해 전달해야합니다.
이유는 배열은 그 자체가 크기 때문이며, 포인터는 대상체가 무엇이든 4바이트 정도의 작은 크기만을
차지하기 때문입니다.

배연의 연산은 배열선두에서부터 출발하지만 포인터는 대상체로 직접 이동해서
읽으므로 액세스 속도가 빠릅니다.

15. Vector 와 ArrayList 차이

공통점
순서가 있는 Collection
List Interface 구현
Data 중복가능

차이점
Vector : 자동 동기화 보장, 동기화가 보장되도록 최적화한 클래스
ArrayList : 자동 동기화를 보장하지 않음


16. Http 와 Https 차이

Http : 웹 브라우저가 웹 서버에 요청하는 프로토콜입니다.
네트워크 안에서 Http 패킷을 가로채 본다면 내용이 그대로 보이게 되는
보안상의 취약점이 있습니다.

Https : 이와 같은 Http의 보안상의 취약점을 보완하기 위해 나온 프로토콜로써
모든 통신 내용을 암호화하는 것이 주된 내용입니다.
암호화 된 내용을 복호화 하여 통신하는 특징이며 암호화 키는 요청을 한 사용자에게만
알려지며 데이터를 암호화하는데는 두 개의 키가 필요합니다.
복호화하는 데에는 두개중 하나만 있으면 되는 특징이 있습니다.

17. Internet Protocol 종류

HTTP(80)
HTTPS(443)
FTP(20,21)
SSH(22)
TELNET(23)
DNS(53) 등이 있으며

HTTP : 웹 문서를 전송하기 위한 프로토콜
FTP : 인터넷 상에서 파일을 교환하기 위한 프로토콜
SSH : 보안 파일 전송 프로토콜
TELNET : 원격지원 프로토콜, 다른 사람의 호스트 컴퓨터에 사용권한을 가지고
있다는 가정하에 원격지에서 액세스 할 수 있도록 하는 프로토콜
DNS : 인터넷 도메인 이름을 IP주소로 바꿔주는 시스템

18. 가상 메모리란?

프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법입니다.
물리 메모리 크기의 제약으로부터 자유로워 진다는 장점이 있습니다.
정리하자면, 한정된 물리 메모리의 한계를 극복하고자 디스크와 같은 느린 저장장치를 활용해
Application들이 더 많은 메모리를 활용 할 수 있게 해주는 것 입니다.


19. Zigbee 와 블루투스 차이

Zigbee 통신이란 근거리 저전력 무선 통신을 위한 프로토콜입니다.
전송 속도 면에서 블루투스나 와이파이 통신이 우수하지만 상대적으로 저렴한 가격으로
무선 네트워크를 구축 할 수 있다는 장점이 있습니다.

또한 네트워크 규모가 방대하여 다수의 센서나 모듈을 활용하는 시스템에 적합합니다.


20. SSL 이란?

인터넷 상에서 정보를 암호화하여 송/수신하는 프로토콜로써 CA라 불리는 서드 파티로부터 서버와
클라이언트를 인증하는 데 사용 된다.
공개키 암호나, 비밀키 암호, 디지털 증명서, 해쉬 함수 등의 보안 기술을 조합하여
위장을 방지할 수 있다.

21. 공개키 / 비밀키 / 대칭키

대칭키 : 하나의 비밀키를 Client-Server 모두 같이 사용하는 것
공개키 : 데이터를 송신자가 수신자의 공개키로 암호화하고 수신자는 자신의 비밀키로 복호화 하는 것
공개키는 누구나 알 수 있지만, 그에 대응하는 비밀 키는 키의 소유자만이 알 수있다.


22. OS란?

컴퓨터 시스템의 자원을 효율적으로 운영 관리 함으로써 사용자가 시스템을 사용하는데 편리함을 제공하는
시스템 소프트웨어입니다.

23. 단위 테스트란 무엇인지? 그리고 그 종류는?

소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차입니다.
보통 모든 함수와 메소드에 대한 테스트 케이스를 작성하는 절차를 말합니다.
즉, 예상하고 실행하고 검증하는 작업이라고 생각합니다.

보통 자바에서 대표적인 유닛 테스트 툴은 Junit입니다.
자바의 단위 테스트 프레임워크의 표준이라고 불리며
Junit의 경우 테스트 결과를 확인하는 것 이외 최적화된 코드를 유추해내는 기능도 제공합니다.
테스트 결과를 TestClass로 로깅하여 개발자에게 테스트 방법 및 Class의 History를 넘겨줄수 있습니다.

24. Junit의 단정문 몇 개 예시로 들자면?

assertEquals = 두 객체의 값이 같은지
assertSame = 두 객체가 같은 객체 인지 판별합니다.

25. CI 란?

소스관리/빌드/배포에서 유지보수를 지원하는 기법입니다.
형상관리 시스템, 즉 Git 과같은 시스템에 있는 Source 파일을 읽어들여
자동으로 빌드해 실행할 수 있는 결과물 형태를 주기적으로 생산해주는 시스템입니다.

대표적으로 자바로 만들어진 Jenkins라는 툴이 있는데 만약 Git을 통해 협업 중이라면
Commit된 소스코드들을 정기적으로 통합시켜주는 것을 도와줍니다.

26. 함수형 언어란?

특징은 변경 가능한 상태를 불변상태로 만들어 SideEffect를 없애는것과
모든 것은 객체라고 생각하는 것 입니다.

SideEffect를 만들지 않는다는 말은 예를들어 함수의 기본이 F(x) = y라고 할때
X를 입력하면 항상 y라는 결과값이 나오게 됩니다.

여기서 함수 안에서 상태를 관리하고 상태에 따라서 결과 값이 달라지면 안된다는 것이 포인트인데
이 상태를 사용하지 않음으로 SideEffect를 제거하는 것 입니다.
보통 변수 보다는 상수를 사용해 제거하는 경우가 많습니다.

27. DI / AOP 란?

DI는 객체간의 의존 관계를 객체 자신이 아닌 외부에서 수행해 준다는 개념입니다.
DI패턴에서 클래스는 의존하는 객체를 전달받기위한 설정 메서드(setter method)나 생성자를 제공할 뿐
직접 의존하는 클래스를 찾지 않습니다.
의존하는 객체를 외부, 즉 통칭 조립기가 삽입 해주기때문에 이를 Dependency Injection 패턴이라고 합니다.
DI의 장점은 단위 테스트에 용이하다는 것 입니다.

AOP는 의존 관계의 복잡성과 코드 중복을 해소해주는 프로그래밍 기법입니다.
즉, 특정 기능이 있는 클래스 안에는 핵심적인 처리만 기술하고, 본질적이지 않은 추가 기능이나 부가 기능은
따로 기술 하는 것 입니다.
Aspect Oriented Programming이라는 이름답게  핵심 로직에 영향을 미치지 않고
공통 모듈을 효과적으로 잘 끼워 넣도록 도와주는 개발방법입니다.


28. Rxjava 란?

데이터를 가공/변형/처리하는 라이브러리로써 처리할 수 있는 데이터의 형태는
크게 Nothing, One, More, Unlimited Datas 가 있습니다.

29. 정렬 알고리즘

1) 선택 정렬
인덱스의 맨앞 값부터 연산을 시작하며, 배열 속 가장 작은 수를 해당 인덱스에 채우는 방식으로 진행

2) 삽입 정렬
현재 위치의 인덱스에서 그 이하 인덱스에 존재하는 값들을 비교하여 자신이 들어갈 위치를 찾음
• 인덱스는 두번째 인덱스부터 시작한다.

3) 버블 정렬
연속된 두 개의 인덱스를 비교하여 정렬하는 방법

4) 합병 정렬(Merge Sort)
분할 정복 방식으로 설계 된 알고리즘
배열의 시작 위치와 종료 위치를 입력받아 더한 후 2로 나눠 반으로 나눈다
이와 같은 방법을 크기가 0이거나 1일 때 까지 반복한다
그리고 나서 나누어진 것들 끼리 비교 연산을 하여 정렬

5) 퀵 정렬
분할 정복 방식으로 설계 된 알고리즘
피벗을 하나 선정 오른쪽은 피벗보다 작은 값이 나올때까지 배열의 끝에서 피벗까지
왼쪽은 피벗보다 큰 값이 나올때까지 배열의 시작에서 피벗까지 진행하다
둘중 한 경우가 나오면 left와 right를 바꾸며 정렬하는 알고리즘

30. IDS / IPS 차이점?

IDS는 컴퓨터나 전산망의 비정상적인 사용이나 오남용 같은 잠재적인 침입 시도 등을 실시간으로
탐지하기 위한 시스템입니다.

IPS는 공격 피해를 최소화 할 수 있는 능동적 보안시스템으로 IDS는 탐지만을 하였다면, IPS는 탐지한 자료를
바탕으로 차단을 할 것 인지, 통과 시킬 것 인지 담당합니다.


31. ACL 과 FW 차이점

ACL은 방화벽 기능 중 하나로 Access Control List 의 약자입니다.
원하지 않는 트래픽이 네트워크를 경유하거나 접근 하는 것을 차단하는데 사용합니다.

ACL 종류로는 Standard Access List, Extended Access List 가 있으며
Standard Access List는 IP Packet의 source address만 검사하여 제어하며
Extended Access List는 IP Packet의 source address 및 destination address
그리고 포트 번호 까지 검사하여 제어합니다.

방화벽은 내부와 외부의 네트워크를 VLAN을 통해 분리하고 외부에서 내부로 들어오는
통신을 막습니다.
방화벽의 기능으로써는 라우팅, ACL 그리고 NAT가 있습니다.

32. Heap / Stack 차이

자바에서는 Stack 영역에 지역변수와 매개변수가 저장됩니다.
즉, 프로그램의 실행 과정에서 임시로 할당되고 그 과정이 끝나면 바로 소멸되는 것들이 저장됩니다.

Heap영역은 흔히 new 명령을 통해 생성된 인스턴스 변수들이 저장됩니다.
메소드의 호출이 끝나도 사라지지않으며 가비지 컬렉터에 의해 지워지거나, JVM이 종료될때까지
남아 있는 것이 특징입니다.

기본적으로 제공되는 데이터 타입이 아닌 참조변수인 경우 스택에 넣었다 꺼내는 과정이 번거로우므로
힙 영역에 실제 값이 저장되며 스택에 그에 해당하는 주소만 저장합니다.

33. 커널이 무엇이고, 어떻게 동작하는가?

운영 체제에서 입출력을 관리하고 시스템 콜을 컴퓨터에 있는 하드웨어가 처리 할 수 있도록 클라이언트 요청을 변환하는 역할을 합니다.
리눅스의 경우 커널은 프로세서 관리(프로세서를 병렬로 연결하여 사용), 프로세스 관리, 메모리 관리 등이 있습니다.

커널의 모드는 두가지가 있으며 첫번째 유저 모드, 두번째 커널 모드 입니다.
유저 모드는 사용자 Application 코드가 실행되며, 시스템 데이터에 제한적인 접근이 가능하며,
하드웨어에 직접 접근이 불가능 합니다.
유저 Application은 시스템 서비스 호출을 하면 유저 모드에서 커널 모드로 전환 됩니다.

두번째로 커널 모드는 시스템의 모든 메모리에 접근 할 수 있고, 모든 CPU 명령을 실행 할 수 있습니다.

동작은 system call에 의한 커널 동작이 있는데 프로세스가 시스템 콜을 통해 커널에게 device로 부터 data
읽기를 요청합니다. 이 후 커널은 I/O 작업을 하기위해 현재 수행중인 프로세스를 잠시 wait queue에 넣습니다.
그리고 새로운 process를 적절한 기준에 의해 선택해 수행하도록 합니다.


34. 리눅스 명령어 간단히

ARP / PING / NETSTAT
리부팅, pid확인

ARP == IP 주소에 대응되는 이더넷 카드의 하드웨어 주소, 즉 MAC 주소를 알아내는 프로토콜
 arp -a => arp 테이블 보기

Ping == 외부 호스트 서버가 네트워크 상으로 접근 가능한지 확인해보는 명령어
Ping ip주소
Ping -c 요청수 -I 초단위 전송간격 ip주소

Netstat == 시스템의 네트워크 연결 목록을 보여줍니다.
모든 연결보기 == netstat -a
Tcp 연결만 보기 == netstat -at
Udp 연결만 보기 == netstat -au
서비스 상태가 listen인 모든 연결 표시 == netstat -al


35. 랜섬웨어 / DDOS 란?

랜섬웨어는 몸값을 뜻하는 Ransom과 소프트웨어 제품을 뜻하는 Ware가 합쳐진 단어로써 악성코드 입니다.
사용자의 중요 데이터를 암호화 시켜 사용할 수 없게 만드는 것이 특징입니다.
예방법은 중요파일 중심으로 암호화를 하기 때문에 중요파일 확장명이 hwp였다면 hwhw와같이 바꿔버리면
랜섬웨어가 중요파일이라 인식하지 않고 파일 확장명을 바꾸는 것 입니다.
가장 중요하고 간단한 것은 데이터 백업 습관을 길들이는 것 입니다.

DDOS는 분산 서비스 거부 공격으로써 다수의 클라이언트를 특정 사이트에 동시 접속하여 
과도한 트래픽을 유발해 서버 부하 발생을 유도 하는 것 입니다.
방지법은 실시간 감시가 가장 정확하다고 생각합니다.

36. Ftp passive mode / active mode 차이점

Active mode는 클라이언트에서 서버 측 21번 포트로 접속을 시도하고
서버가 data 포트(20번 포트)를 클라이언트에 연결해 데이터를 보내는 방식입니다.
서버가 클라이언트에 접속을 시도하는 것 이기 때문에 Active라는 이름이 지어졌습니다.
• 클라이언트에 방화벽같은게 설정되어 있으면 연결이 안됨

Passive mode는 Active mode의 문제점을 해결하기 위해 고안된 방법으로
Active mode에서 data 포트로 사용했던 20번 포트를 사용하지 않고 1024 이후의 비 특권 포트를 사용합니다.
즉, Passive mode는 클라이언트에서 서버쪽 21 포트로 접속 시도하고 데이터 포트도 클라이언트에서
서버의 임의의 포트로 접속하여 데이터를 받아오는 방식 입니다.

37. Sql 인젝션이란?

웹 해킹 공격 중 많은 부분을 차지하는 공격 기법으로 
Sql 조건식을 변경하여 인증을 우회하는 방식으로 알고있습니다.
Ex) select * from user where id = 'test' and pass = '1234'를
	Select * from user where id ='test' and pass = '8' or '1=1'; 

38. OWASP 란 무엇인지? 이에 포함되는 해킹방법과 방어 설명

오픈 소스 웹 어플리케이션 보안 프로젝트 입니다.
(Opensource Web Application Security Project)

즉 어플리케이션 보안에만 전념하는 것 입니다.

10대 문제점이 있는데
첫번째 Injection 이 있습니다.
주된 예로 SQL Injection이 있는데 예상하지 못하는 명령을 실행하거나
적절한 권한 없이 데이터에 접근하도록 인터프리터를 속이는 것 입니다.

두번째로는 인증 및 세션 관리 취약점 입니다.
인증 및 세션 관리와 관련된 Application 기능이 정확하게 구현 되어 있지 않아서
공격자가 패스워드, 키 혹은 세션 토큰을 해킹하거나 다른 구현 취약점을 공격하여
다른 사용자 계정을 일시적 혹은 영구적으로 탈취함을 허용하는 것을 말합니다.
JWT가 하나의 방법이라고 생각하는데 보안을 전문적으로 공부한 것이 아니라 잘모르겠습니다.

39. DHCP 란?

호스트의 IP 주소와 각종 TCP/IP 프로토콜의 기본 설정을 클라이언트에게 자동적으로 제공해주는
프로토콜 입니다.
- DHCP 가 무엇을 할당?
IP주소를 할당합니다.

- DHCP 서버란?
네트워크 인터페이스를 위해서 IP주소를 가지고 있는 서버에서 실행되는 프로그램입니다.

- 사설 IP와 공인IP 차이?
공유기를 사용하는 경우 공인 아이피 하나를 다같이 공유해 사용하는데
이 각각의 네트워크를 구별하기 위해 사설 IP를 부여합니다.

- 공인 IP는 어느 기관에서 나누는가?
가장 높은 기관은 IANA로 알고있으며 한국의 기관은 한국인터넷정보센터로 알고있습니다.

- Ipv6 란?
Ipv6는 128비트 주소 체계로 기존의 Ipv4의 고갈의 문제가 있었으며 IOT 시대에 대비해 등장하게 되었습니다.


- 서브넷 마스크란?
주어진 IP주소를 네트워크 환경에 맞게 나누어 주기 위해서 씌워주는 이진수의 조합입니다.
서브넷 없이 브로드캐스트를 하면 도메인이 커져서 브로드 캐스트가 너무 많이 발생하게 되기 때문입니다.
서브넷 마스크는 커다란 네트워크를 잘게 나누기 위해서 필요합니다.

40. L2 스위치란?

패킷의 MAC 주소를 읽어 스위칭 하고 기본적인 동작은 모든 자료를 보내는 곳으로
수신 번지를 전송합니다.


41. 바이러스와 웜의 차이?

-악성코드 분류방법?
-트로이 목마, 트로이잔 이란?

42. 리눅스 password 명령어 말고 수동으로 변경 방법?

Etc/passwd 에 원하는 계정을 작성하면 됩니다.


43. 피싱, 스미싱, 파밍의 특징과 차이점?

피싱
개인정보와 낚시의 합성어로 이메일 등을 수신자가 신뢰할 만한 출처로 위장하여 개인정보를 빼내는
해킹기법 입니다.

스미싱
문자메시지와 피싱의 합성어로 문자메시지를 이용한 피싱 기법 입니다.

파밍
특정 사이트가 공식적으로 운용하고 있던 도메인 자체를 중간에서 탈취하는 것입니다.
악성코드에 감염된 사용자의 pc는 사용자가 정상적인 주소를 입력해도 파밍사이트로 연결 시키고
사용자의 주소창에는 정상적인 사이트로 표시합니다.

44. 안드로이드 생명주기

onCreate()
액티비티가 생성될 때 사용, 사용자 인터페이스 초기화에 사용

onStart()
액티비티가 사용자에게 보여지기 직전에 호출 됨

onResume()
액티비티가 보이지만 사용자와 상호작용을 할 수 없음

onPause()
액티비티가 보이긴 하지만 다른 액티비티에 의해서 가려질 때 호출 됨

onStop()
액티비티가 더 이상 사용자에게 보여지지 않을 때 호출 됨

onDestroy()
액티비티가 소멸할 때 호출 됨, finish() 메소드가 호출되거나 시스템이
메모리 확보를 위해 액티비티를 제거 할 때 호출 됩니다.

onPause() -> onResume() -> 액티비티 실행
onStop() -> onRestart() -> onStart() -> onResume() -> 액티비티 실행
• 다이얼로그 등에 의해 포커스를 잃은 경우 onPause()가 실행되지않지만
다이얼로그 스타일의 액티비티가 실행되면 onPause()가 실행 됩니다.

45. 안드로이드 4대 요소

Activity, Service, ContentProvider, BroadCastReceiver 가 있습니다.
Activity는 기본적으로 사용자에게 보여지는 하나의 UI입니다.

Service는 백그라운드에서 실행되는 컴포넌트로 오래 실행되는 작업이나
원격 프로세스를 위한 작업을 할 때 사용합니다.

ContentProvider는 데이터를 관리하고 다른 App의 데이터를 제공하는
컴포넌트입니다. 데이터는 파일 시스템이나 SQLite 데이터베이스 등에 저장될
수 있으며 다른 App의 데이터를 쿼리하거나 변경이 가능합니다.

BroadCastReceiver는 안드로이드 단말기에서 발생하는 다양한 이벤트/ 정보를
받고 반응하는 컴포넌트 입니다. 예를 들어 시스템 부팅, 배터리 부족의 이벤트를 수신하는
것이 있습니다.

46. 리버싱이 무엇이며 어떤 툴이 있는지?

리버싱이랑 일명 디컴파일로 속칭되며 구현 되어있는 프로그램의 소스코드를
리버스 엔지니어링을 통해 참고하자는 의도가 있습니다.

사용해본 Tool로는 Dex2Jar를 통해 apk파일을 jar로 변경하고
Jd-gui를 통해 jar로 변환된 파일의 소스코드를 들여다 본 적이 있습니다.

중국의 어떤 채팅 앱을 디컴파일해서 자동로그인 관련 기능을 어디에 저장하는지
파악해서 다른 휴대폰에서 이전의 휴대폰 사용자인척 로그인하려고 시도하기 위해서
사용했으며 ConfigStore2.dat에 저장되어 있던 것을 확인해 성공했습니다.


47. Java에서 Collection class에서 generic을 사용하는 이유

특정 타입만 포함 될 수 있도록 제한하기 위해 Generic을 사용하며
컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여
런타임 시에 발생 할 수 있는 잠재적인 예외를 컴파일 타임에
잡아 낼 수 있습니다.

48. 객체의 직렬화 란?

객체에 저장되어 있는 데이터를 스트림에 바로 쓰기 위해 연속적인 데이터로 변환
하는 것을 말합니다. Io패키지 내에 구현되어 있는 Serializable 인터페이스를 상속 받으면
직렬화가 가능한 클래스로 변경이 가능합니다.

혹여 직렬화 대상의 클래스이 직렬화가 불가능한 객체가 포함 되어있으면
Transient 키워드를 통해 해당 객체를 제외 할 수 있습니다.

49. 자바에서 쓰레드의 동기화와 데드락 이란?

두개 이상의 쓰레드가 하나의 공유 자원에 접근하여 값을 변경하려 할 때
동기화를 하지 않으면 값이 중구난방으로 변경 될 가능성이 높습니다.
따라서 공유 변수에 synchronized 키워드를 사용하여 하나의 쓰레드가
공유 자원을 점유하고 있을 경우 다른 쓰레드가 잠시 대기 상태에 머무르도록
하는 것 입니다.

A라는 쓰레드가 test라는 공유 변수에 락을 한 상태로 작업을 진행하고 있고
B라는 쓰레드가 test2라는 공유 변수에 락을 한 상태로 작업을 진행하고 있을 때

A의 쓰레드에서 test2 공유 변수가 필요한 코드를 만났지만 B가 선점하고있고
이와중에 B의 쓰레드에서 test 공유 변수가 필요한 코드를 만나서 A가 선점하고 있는 경우
무한정 대기상태에 이르게 되며 이를 데드락이라 합니다.

50. String / StringBuffer / StringBuilder에 대해 설명?

String은 한번 생성되면 변경이 불가능한 immutable 성질을 가지고 있습니다.
변경이 적고 참조만 많거나 여러 개의 쓰레드에서 공유하는 문자열일 경우
별다른 동기화를 구현하지 않고 안전하게 공유될 수 있다는 장점이 있습니다.

StringBuffer와 StringBuilder는 새로운 객체를 생성하지 않고 기존 문자열을 변경합니다.
StringBuilder의 경우 쓰레드의 동기화를 지원하지 않기 때문에 쓰레드에서 사용하기 위해서는
StringBuffer를 이용해야합니다.

하지만 StringBuilder는 동기화를 처리하지 않기때문에 쓰레드를 활용하지 않는 환경에서는
StringBuilder를 사용하는 것이 유리합니다.

51. JVM 메모리 구조와 Garbage Collection을 설명?

JVM의 구조는 크게 class, stack, heap, native method, pc 레지스터로 나뉩니다.
Class 영역에는 클래스, 변수, 메소드, 상수, static 변수에 대한 정보가 저장됩니다.

Stack 영역에는 메소드 호출에 따른 메소드를 위한 공간인 프레임이 생성되어
메소드 안에서 필요한 각종 값이 임시 저장 됩니다.

Heap 영역에는 new 연산자로 생성된 객체와 배열이 저장되는 공간입니다.
그게 permanent generation, new, old 영역으로 나뉩니다.
Permanent generation 영역은 생성된 객체들의 주소 값이 저장 됩니다.
new 영역은 다시 eden, survivor 영역으로 나뉘어지며
new의 eden는 객체들이 최초로 생성되는 영역이며
new의 survivor은 eden 영역에서 참조되는 객체들이 저장되는 공간입니다.

마지막으로 old 영역은 new 영역에서 일정 시간 참조 되고 있는 객체 들이
저장 되는 공간 입니다.

Native method 영역은 자바 이외의 언어에서 제공되는 메소드가 저장되는
공간입니다.

PC 레지스터 영역은 쓰레드가 생성될 때마다 생성되는 영역으로 쓰레드가 어떤 명령을
행할지 저장합니다.

GC, 가비지 컬렉션은 크게 minor와 major로 나뉩니다.
Minor에서는 new 영역을 대상으로 실행 됩니다.

첫째로 new 영역안의 eden 영역이 가득 차면 suvivor1 영역으로
이동 시킨 후 나머지 영역의 객체를 삭제합니다.

둘째로 eden 영역과 survivor1 영역이 기준치 이상으로 차면 참조가
실제로 되고 있는지 검사 한 후 참조되는 객체만 survivor2 영역에 복사 후
나머지 영역의 객체를 삭제합니다.

마지막으로 일정시간 참조되고 있는 객체들을 old 영역으로 이동시킵니다.

Major 영역에서는 old 영역을 대상으로 실행 됩니다.
Minor에 비해 시간이 오래 걸리며 old 영역이 가득 차 프로세스가 정지 될
가능성이 있는 경우 실행 됩니다. Old 영역에 있는 모든 객체를 검사하여
참조되지 않은 객체들을 한번에 삭제합니다.

52. 자바의 String 클래스의 intern 메소드와 상수 풀에 대해 설명?

자바의 모든 String 객체는 상수 풀에서 관리됩니다.
상수 풀은 heap의 permanent generation 영역에 생성되어 자바 프로세스가 종료 될 때 까지 함께 합니다.
상수 풀을 이용하는 이유는 문자열에 대한 효율적인 메모리 관리 때문입니다.

같은 문자열이 존재하는데 동일한 문자열이 상수 풀에 삽입되는 경우 heap에 생성 되었던 문자열을 해제하고
상수 풀에서 관리하는 레퍼런스로 반환 해 줌으로써 메모리 낭비 현상을 해결합니다.

String 클래스의 intern 메소드는 heap 영역에 있는 문자열 객체를 상수 풀로 이전시키는 메소드 입니다.
실행 후 해당 문자열과 동일한 문자열이 없다면 해당 객체를 상수 풀에 등록하고, heap 영역에서 해제 후
레퍼런스 값을 반환합니다.

만약 해당 문자열과 동일한 문자열이 존재한다면 해당 객체를 heap 영역에서 해제 후 상수 풀에 있는 해당
문자열의 레퍼런스를 반환 해줍니다.

String 객체를 생성하는 방법에는 2가지가 있습니다.
첫번째는 리터럴("")을 사용하는 방법입니다.
내부적으로 String 생성자로 객체를 heap 영역에 생성한 후 intern 메소드가 호출되어
상수 풀에 해당 객체를 등록하는 과정을 거칩니다.

두번째는 String 생성자를 이용하는 방법 입니다.
이 경우 heap의 영역에 단순한 인스턴스로 저장합니다. 그래서 상수 풀에 등록 되지않는데
명시적으로 intern 메소드를 호출하여 상수 풀로 옮겨 줄 수 있습니다.

마지막 특징은 상수 풀에 등록 되어 있는 문자열 객체일 경우 == 연산자를 이용하면 논리 값을 판단
할 수 있지만 String 생성자로 생성된 문자열 객체의 경우 두 문자열 객체의 레퍼런스 값이 다르기 때문에
비교 할 수 없습니다. 이 경우에는 String 클래스의 Equals를 이용하여 문자열의 값을 비교 할 수 있습니다.

53. RxAndroid 란?

안드로이드에서 Observer 패턴, Iterator 패턴을 사용 할 수 있게 도와주는 라이브러리 입니다.
